PUSH1 00 // 00 is the opcode for STOP
PUSH1 00 // this will be used as the offset of MSTORE8 that store 1 byte in memory
MSTORE8 // will store in memory from offset 0 the `00` value (from the first PUSH1)
PUSH1 01 // how many bytes must be returned
PUSH1 00 // from which memory offset return those bytes
RETURN

00      36        CALLDATASIZE
01      6000      PUSH1 00
03      80        DUP1
04      37        CALLDATACOPY
05      36        CALLDATASIZE
06      6000      PUSH1 00
08      6000      PUSH1 00
0A      F0        CREATE
0B      3B        EXTCODESIZE
0C      6001      PUSH1 01
0E      14        EQ
0F      6013      PUSH1 13
11      57        JUMPI
12      FD        REVERT
13      5B        JUMPDEST
14      00        STOP

create: takes the value in wei, offset (starting location in memory that 
contains the code for the new contract to run), and byte size of the data to 
copy (size of initalization code)

Stack input
value: value in wei to send to the new account.
offset: byte offset in the memory in bytes, the initialisation code for the new account.
size: byte size to copy (size of the initialisation code).

Stack output
address: the address of the deployed contract, 0 if the deployment failed. 

"Creates a new contract. Enters a new sub context of the calculated destination
address and executes the provided initialisation code, then resumes the current
context.

Should deployment succeed, the new account's code is set to the return 
data resulting from executing the initialisation code."

create returns the runtime code 
Return at the end of a contract deployment returns the run time code
(which was pushed to memory), and the size of that code 

constructor is a part of creation code, however is not apart of the runtime code.
Meaning once the code is deployed the constructor will not be present. 

code in contract returned by the return opcode is the runtime code that
will be executed whenever the contract is called.

need to push 1 byte size instruction to memory 

PUSH1       

CODECOPY:

Stack input
destOffset: byte offset in the memory where the result will be copied.
offset: byte offset in the code to copy.
size: byte size to copy.

Stack output
size: byte size of the code.

RETURN:
Stack input
offset: byte offset in the memory in bytes, to copy what will be the return data of this 
context.
size: byte size to copy (size of the return data).

EXTCODESIZE:
Stack input
address: 20-byte address of the contract to query.

MSTORE8:
Stack input
offset: offset in the memory in bytes.
value: 1-byte value to write in the memory 
(the least significant byte of the 32-byte stack value).


Regular execution uses CODECOPY to load in from starting line in byte code and size of bytecode

******** SHOW ***********************

Why is this not valid bytecode? 
00 -> one instruction (STOP)
push 01 -> byte size to copy
push 00 -> byte offset in the code to copy (line 0)
push 00 -> byte offset in the memory where the result will be copied. 
39 -> copycode (bytecode) to memory location 00 (returns byte size of the code on stack)
push 00 -> byte offset in the memory to copy what will be the return data of this context.
F3

00600160006000396000F3

https://ibb.co/NLBkVL4 -> regular execution CODECOPY reads into memory 
starting from line 142 (008e) and then returns the contract code, and size

******** SHOW ***********************
i'll admit ended up having to look it up saw they use MSTORE8 to load 1 byte which makes sense

https://www.evm.codes/playground?callValue=0&unit=Wei&callData=0x00600160006000396000F3&codeType=Bytecode&code='36600080373660006000F03B600114601357FD5B00'_

----------------------------------------- 
PUSH1 00 // 00 is the opcode for STOP
PUSH1 00 // this will be used as the offset of MSTORE8 that store 1 byte in memory
MSTORE8 // will store in memory from offset 0 the `00` value (from the first PUSH1)
PUSH1 01 // how many bytes must be returned
PUSH1 00 // from which memory offset return those bytes
RETURN

600060005360016000F3

****************************************************
say we are running create and create is this:

Stack input
value: value in wei to send to the new account.
offset: byte offset in the memory in bytes, the initialisation code for the new account.
size: byte size to copy (size of the initialisation code)

How can I reference the first line in the code? 

---------------------
PUZZLE 8
CALLDATASIZE -> 00
PUSH1 -> 00
DUP1 -> 00
CALLDATACOPY -> pop off last 3 will be size of input automatically
---
CALLDATASIZE -> 00
PUSH1 -> 00
PUSH1 -> 00
---
CREATE -> pop off last 3 and read memory 0 (returns address)
PUSH1 -> 00
DUP1 -> 00
DUP1 -> 00
DUP1 -> 00
DUP1 -> 00
---
SWAP5 -> exchange 1st and 6th Address will be at top of stack and DUP1 -> 00 at bottom

GAS -> Pushes to stack remaining gas to transaction
[gas, address, 00, 00, 00, 00, 00]

CALL -> gas, address, value: value in wei, argsOffset: byte offset in the memory, 
argsSize: byte size to copy, retOffset: byte offset in the memory in bytes
retSize: byte size to copy).
Stack input

    gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub context is returned to this one.
    address: the account which context to execute.
    value: value in wei to send to the account.
    argsOffset: byte offset in the memory in bytes, the calldata of the sub context.
    argsSize: byte size to copy (size of the calldata).
    retOffset: byte offset in the memory in bytes, where to store the return data of the sub context.
    retSize: byte size to copy (size of the return data). 
[0]

argsSize: byte size to copy (How is byte size to copy 0??)

Must create a contract that returns a revert, as when call reverts it returns a 0
PUSH1 FD // Pushes opcode revert
PUSH1 00 // Push 00 to stack
MSTORE8 // store in memory position 0, revert opcode
PUSH1 01 // pushes bytesize to return
PUSH1 00 // location in memory to start reading from
RETURN

60FD60005360016000F3 -> 8 solution

---------------------------
PUZZLE 9
CALLDATASIZE
PUSH1 03
LT
PUSH1 09
JUMPI
pass in input of more than 3 bytes  to jump to 09 jumpdest
-----
CALLVALUE ->    
CALLDATASIZE
MUL
PUSH1 08
EQ
PUSH1 14
JUMPI

pass in callvalue of 1, with calldata size of 8 (0x0000000000000000)

------------------------
Puzzle 10
CODESIZE -> 27
CALLVALUE -> must be less than 27
SWAP1 [CODESIZE, CALLVALUE]
GT -> CODESIZE must be greater than CALLVALUE ( CODESIZE  > CALLVALUE)
PUSH1 08
JUMPI
pass in callvalue less than 27
----------------------------------
CALLDATASIZE -> must divide evenly into 3 i.e 6
PUSH2 0003
[0003, CALLDATASIZE]
SWAP1
[CALLDATASIZE, 0003]
MOD 
[0]
ISZERO
[1]
CALLVALUE -> 9
PUSH1 0A
ADD -> callvalue (num < 27) + 10 = 19
JUMPI

put in 15 as callvalue (15 + 10) = 25 (which is 19 in hex)

Overwhelemed by the theory really want to know everything perfectly but feel like 
i'm not grasping all of it. Have learned a lot though 


