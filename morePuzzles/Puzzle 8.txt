00      34        CALLVALUE
01      15        ISZERO
02      19        NOT
03      6007      PUSH1 07
05      57        JUMPI
06      FD        REVERT
07      5B        JUMPDEST
08      36        CALLDATASIZE
09      6000      PUSH1 00
0B      6000      PUSH1 00
0D      37        CALLDATACOPY
0E      36        CALLDATASIZE
0F      6000      PUSH1 00
11      6000      PUSH1 00
13      F0        CREATE
14      47        SELFBALANCE
15      6000      PUSH1 00
17      6000      PUSH1 00
19      6000      PUSH1 00
1B      6000      PUSH1 00
1D      47        SELFBALANCE
1E      86        DUP7
1F      5A        GAS
20      F1        CALL
21      6001      PUSH1 01
23      14        EQ
24      6028      PUSH1 28
26      57        JUMPI
27      FD        REVERT
28      5B        JUMPDEST
29      47        SELFBALANCE
2A      14        EQ
2B      602F      PUSH1 2F
2D      57        JUMPI
2E      FD        REVERT
2F      5B        JUMPDEST
30      00        STOP

construct a contract that when called will not accept ether. 
Create an invalid contract so when called still returns true(1)?

In CALL step the contract from the CREATE step runtimecode is exected 
passing to it all the ether in the contract. 

Then the balance is checked against the balance after the call.
If these values are the same then the last JUMPI value portion will be satisfactory.
(1 is outcome of EQ operation).

we can just pass in a CALLVALUE of 0 so SELFBALANCE before and after is the same.
As well as an invalid contract so that no ether is sent out in the first place
